name: Auto Label Issues and PRs

on:
  issues:
    types: [opened, edited, reopened]
  pull_request:
    types: [opened, edited, reopened, synchronize]

jobs:
  auto-label:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Auto-label based on title and content
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const issue = context.payload.issue || context.payload.pull_request;
            const isIssue = !!context.payload.issue;
            const title = issue.title.toLowerCase();
            const body = (issue.body || '').toLowerCase();
            const labels = [];

            // Priority detection
            if (title.includes('[critical]') || title.includes('[urgent]') || body.includes('priority: critical')) {
              labels.push('priority: critical');
            } else if (title.includes('[high]') || body.includes('priority: high')) {
              labels.push('priority: high');
            } else if (title.includes('[low]') || body.includes('priority: low')) {
              labels.push('priority: low');
            } else if (!title.includes('[p0]') && !title.includes('[p1]') && !title.includes('[p2]') && !title.includes('[p3]')) {
              labels.push('priority: medium');
            }

            // Type detection
            if (title.includes('[goal]') || title.includes('goal:') || body.includes('type: goal-proposal')) {
              labels.push('type: goal-proposal');
            } else if (title.includes('[project]') || body.includes('type: project-proposal')) {
              labels.push('type: project-proposal');
            } else if (title.includes('[governance]') || body.includes('type: governance')) {
              labels.push('type: governance');
            } else if (title.includes('bug') || title.includes('fix') || title.includes('error') || title.includes('issue')) {
              labels.push('type: bug');
            } else if (title.includes('feature') || title.includes('add') || title.includes('implement')) {
              labels.push('type: feature');
            } else if (title.includes('docs') || title.includes('documentation') || title.includes('readme')) {
              labels.push('type: documentation');
            } else if (title.includes('enhance') || title.includes('improve') || title.includes('update')) {
              labels.push('type: enhancement');
            } else if (title.includes('refactor') || title.includes('cleanup')) {
              labels.push('type: refactoring');
            } else if (title.includes('security') || title.includes('vulnerability') || title.includes('cve')) {
              labels.push('type: security');
            } else if (title.includes('infrastructure') || title.includes('ci/cd') || title.includes('deployment')) {
              labels.push('type: infrastructure');
            }

            // Area/Component detection
            if (body.includes('discord') || title.includes('discord')) {
              labels.push('area: discord');
            }
            if (body.includes('web') || title.includes('web') || title.includes('website')) {
              labels.push('area: web');
            }
            if (body.includes('bot') || title.includes('bot')) {
              labels.push('area: bot');
            }
            if (body.includes('api') || title.includes('api')) {
              labels.push('area: api');
            }

            // Status detection
            if (isIssue && !issue.assignee && !issue.assignees.length) {
              labels.push('status: needs-triage');
            }
            if (body.includes('blocked') || title.includes('[blocked]')) {
              labels.push('status: blocked');
            }

            // Good first issue detection
            if (title.includes('good first issue') || body.includes('good first issue') ||
                (title.includes('simple') || title.includes('easy')) && (title.includes('fix') || title.includes('update'))) {
              labels.push('good first issue');
            }

            // Size estimation based on description
            if (body.includes('size: xs') || body.length < 200) {
              labels.push('size: XS');
            } else if (body.includes('size: s') || body.length < 500) {
              labels.push('size: S');
            } else if (body.includes('size: m') || body.length < 1000) {
              labels.push('size: M');
            } else if (body.includes('size: l') || body.length < 2000) {
              labels.push('size: L');
            } else if (body.includes('size: xl') || body.length >= 2000) {
              labels.push('size: XL');
            }

            // Apply labels if any were detected
            if (labels.length > 0) {
              const uniqueLabels = [...new Set(labels)];
              console.log(`Adding labels: ${uniqueLabels.join(', ')}`);

              if (isIssue) {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: uniqueLabels
                });
              } else {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number,
                  labels: uniqueLabels
                });
              }

              core.summary
                .addHeading('Auto-labeling Summary')
                .addRaw(`Applied ${uniqueLabels.length} label(s) to ${isIssue ? 'issue' : 'PR'} #${issue.number}`)
                .addList(uniqueLabels)
                .write();
            } else {
              console.log('No automatic labels applied');
            }

      - name: Label based on files changed (PRs only)
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const files = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number
            });

            const labels = [];
            const filenames = files.data.map(f => f.filename);

            // Detect changes by file type
            if (filenames.some(f => f.includes('.md') || f.includes('README'))) {
              labels.push('type: documentation');
            }
            if (filenames.some(f => f.includes('.yml') || f.includes('.yaml') || f.includes('.github/workflows'))) {
              labels.push('type: infrastructure');
            }
            if (filenames.some(f => f.includes('test') || f.includes('spec'))) {
              labels.push('type: test');
            }
            if (filenames.some(f => f.includes('GOVERNANCE') || f.includes('CONTRIBUTING'))) {
              labels.push('type: governance');
            }
            if (filenames.some(f => f.includes('SECURITY'))) {
              labels.push('type: security');
            }

            // Apply labels
            if (labels.length > 0) {
              const uniqueLabels = [...new Set(labels)];
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: uniqueLabels
              });
            }
