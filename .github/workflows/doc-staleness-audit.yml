name: Weekly Document Staleness Audit

on:
  schedule:
    - cron: '0 9 * * 1'  # Every Monday at 9:00 UTC
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  audit-docs:
    name: Audit Document Freshness
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check document dates and create issues
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');

            const today = new Date();
            const staleIssues = [];

            // Map of docs to check with their expected review cadences
            const docs = [
              { file: 'PROJECT_BOARD_GUIDE.md', cadence: 'quarterly' },
              { file: 'GOALS.md', cadence: 'monthly' },
              { file: 'MILESTONES_OVERVIEW.md', cadence: 'monthly' },
              { file: 'SECURITY.md', cadence: 'semi-annual' },
              { file: 'CONTRIBUTING.md', cadence: 'quarterly' },
              { file: 'GOVERNANCE.md', cadence: 'quarterly' },
              { file: 'GOVERNANCE_PROTOCOL.md', cadence: 'quarterly' },
              { file: 'DOCUMENT_CLASSIFICATION_POLICY.md', cadence: 'quarterly' }
            ];

            for (const doc of docs) {
              const filePath = path.join(process.env.GITHUB_WORKSPACE, doc.file);
              if (!fs.existsSync(filePath)) continue;

              const content = fs.readFileSync(filePath, 'utf8');

              // Check Next Review date
              const reviewMatch = content.match(/\*\*Next Review\*\*:\s*(.+)/i)
                || content.match(/Next Review:\s*(.+)/i);

              if (reviewMatch) {
                const reviewDate = new Date(reviewMatch[1].trim());
                if (!isNaN(reviewDate.getTime()) && reviewDate < today) {
                  const daysOverdue = Math.floor((today - reviewDate) / (1000 * 60 * 60 * 24));
                  staleIssues.push({
                    file: doc.file,
                    reason: `Past review date by ${daysOverdue} days (was due ${reviewMatch[1].trim()})`,
                    cadence: doc.cadence
                  });
                }
              }

              // Check Last Updated date
              const updatedMatch = content.match(/\*\*Last Updated\*\*:\s*(.+)/i)
                || content.match(/Last Updated:\s*(.+)/i);

              if (updatedMatch) {
                const updatedDate = new Date(updatedMatch[1].trim());
                if (!isNaN(updatedDate.getTime())) {
                  const daysSince = Math.floor((today - updatedDate) / (1000 * 60 * 60 * 24));
                  const threshold = doc.cadence === 'monthly' ? 45 : doc.cadence === 'quarterly' ? 120 : 200;

                  if (daysSince > threshold) {
                    const existing = staleIssues.find(s => s.file === doc.file);
                    if (!existing) {
                      staleIssues.push({
                        file: doc.file,
                        reason: `Not updated in ${daysSince} days (threshold: ${threshold} for ${doc.cadence} docs)`,
                        cadence: doc.cadence
                      });
                    }
                  }
                }
              }
            }

            // Create issues for stale docs (check for duplicates first)
            for (const stale of staleIssues) {
              const title = `[DOC REVIEW] ${stale.file} needs update`;

              // Check if issue already exists
              const existing = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                labels: 'type: documentation',
                per_page: 100
              });

              const duplicate = existing.data.find(i => i.title === title);
              if (duplicate) continue;

              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: `## Document Review Required\n\n**File**: \`${stale.file}\`\n**Reason**: ${stale.reason}\n**Expected cadence**: ${stale.cadence}\n\n### Action Required\n\n1. Review the document for accuracy\n2. Update any stale content\n3. Bump the \`Last Updated\` date\n4. Set the next \`Next Review\` date\n5. Verify no confidential content per [DOCUMENT_CLASSIFICATION_POLICY.md](DOCUMENT_CLASSIFICATION_POLICY.md)\n\n---\n*Auto-generated by doc-staleness-audit workflow*`,
                labels: ['type: documentation', 'status: needs-triage']
              });
            }

            // Generate summary
            let summary = '## Weekly Document Staleness Audit\n\n';
            summary += `**Date**: ${today.toISOString().split('T')[0]}\n`;
            summary += `**Documents checked**: ${docs.length}\n`;
            summary += `**Stale documents found**: ${staleIssues.length}\n\n`;

            if (staleIssues.length > 0) {
              summary += '| Document | Issue | Cadence |\n|---|---|---|\n';
              for (const s of staleIssues) {
                summary += `| ${s.file} | ${s.reason} | ${s.cadence} |\n`;
              }
            } else {
              summary += 'All documents are within their expected freshness thresholds.\n';
            }

            core.summary.addRaw(summary);
            await core.summary.write();
